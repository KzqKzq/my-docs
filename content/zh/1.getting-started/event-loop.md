---
title: 事件循环基本原理
seo:
  title: Event-loop file
  description: ""
links: []
---

# **1 线程和进程**

程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为**进程**

进程之间是独立的，通信是双方允许的情况可以进行。

浏览器是一个多进程多线程实现的，对于前端工程师来讲主要重点关注三个进程。

- 浏览器进程
- 网络进程
- 渲染进程

# 2 **渲染主线程**

渲染进程=>开启渲染主线程

**渲染主线程最繁忙的线程**

js css html 布局、图层、样式计算、事件处理函数等都是对渲染主线程负责

![1](/1.webp)

渲染主线程的执行逻辑

- 在最开始的时候，渲染主线程会进入**一个无限循环**（不会结束的for循环）
- 每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。
- 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务
- 这样一来，就可以让每个任务有条不的、持续的进行下去了。

何为异步？

**代码在执行过程中，会遇到一些无法立即处理的任务，比如：**

- 计时完成后需要执行的任务 -- setTimeout、setInterval
- 网络通信完成后需要执行的任务-－XHR、Fetch
- 用户操作后需要执行的任务--addEventListener

如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死]

**同步**

![何为异步](https://nqqyrgkfvhsetxqnklie.supabase.co/storage/v1/object/public/blog-images/uploads/1765808414848-avqugh.webp)

**异步**

![异步](https://nqqyrgkfvhsetxqnklie.supabase.co/storage/v1/object/public/blog-images/uploads/1765808841740-prepvm.webp)

## **3 渲染主线程的任务执行逻辑**

先看图，主线程中有很多不同类型的任务队列，不只图中的三种，但这种是比较重要，w3c规定微队列具有最高执行优先级，其他的队列优先级视情况而定，在当前的浏览器规中，交互队列优先级大于延时队列，在一次执行上下文中是按照微队列> 交互队列 > 延时队列 的优先级依次清空每一个队列，因此在遇到复杂提的时候按照下面的结构画图开始分析最优。

![渲染主线程的任务执行逻辑](https://nqqyrgkfvhsetxqnklie.supabase.co/storage/v1/object/public/blog-images/uploads/1765894644104-2viwxp.webp)

## **4 总结**

**单线程程是异步产生的原因**

**事件循环是异步的实现方式**

**微队列> 交互队列 > 延时队列的优先级**
